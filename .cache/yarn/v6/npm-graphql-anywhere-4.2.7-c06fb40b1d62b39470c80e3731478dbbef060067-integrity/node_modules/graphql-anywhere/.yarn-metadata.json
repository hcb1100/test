{
  "manifest": {
    "name": "graphql-anywhere",
    "version": "4.2.7",
    "description": "Run GraphQL queries with no schema and just one resolver",
    "main": "./lib/bundle.cjs.js",
    "module": "./lib/bundle.esm.js",
    "typings": "./lib/index.d.ts",
    "sideEffects": false,
    "scripts": {
      "prepare": "npm run lint && npm run build",
      "coverage": "jest --coverage",
      "test": "tsc -p tsconfig.json --noEmit && jest",
      "build": "tsc -b .",
      "postbuild": "npm run bundle",
      "bundle": "npx rollup -c rollup.config.js",
      "watch": "../../node_modules/tsc-watch/index.js --onSuccess \"npm run postbuild\"",
      "prepublishOnly": "npm run build",
      "lint": "tslint -c \"../../config/tslint.json\" -p tsconfig.json src/*.ts",
      "clean": "rm -rf coverage/* lib/*"
    },
    "repository": {
      "type": "git",
      "url": "git+https://github.com/apollographql/apollo-client.git"
    },
    "bugs": {
      "url": "https://github.com/apollographql/apollo-client/issues"
    },
    "homepage": "https://github.com/apollographql/apollo-client/tree/master/packages/graphql-anywhere",
    "keywords": [
      "ecmascript",
      "es2015",
      "jsnext",
      "javascript",
      "relay",
      "npm",
      "react"
    ],
    "author": {
      "name": "Sashko Stubailo",
      "email": "sashko@stubailo.com"
    },
    "contributors": [
      {
        "name": "James Burgess",
        "email": "jamesmillerburgess@gmail.com"
      }
    ],
    "license": "MIT",
    "dependencies": {
      "apollo-utilities": "^1.3.4",
      "ts-invariant": "^0.3.2",
      "tslib": "^1.10.0"
    },
    "peerDependencies": {
      "graphql": "^0.11.0 || ^0.12.0 || ^0.13.0 || ^14.0.0 || ^15.0.0"
    },
    "gitHead": "d22394c419ff7d678afb5e7d4cd1df16ed803ead",
    "_registry": "npm",
    "_loc": "/home/tel/.cache/yarn/v6/npm-graphql-anywhere-4.2.7-c06fb40b1d62b39470c80e3731478dbbef060067-integrity/node_modules/graphql-anywhere/package.json",
    "readmeFilename": "README.md",
    "readme": "# graphql-anywhere\n\n[![npm version](https://badge.fury.io/js/graphql-anywhere.svg)](https://badge.fury.io/js/graphql-anywhere)\n[![Build Status](https://travis-ci.org/apollographql/graphql-anywhere.svg?branch=master)](https://travis-ci.org/apollostack/graphql-anywhere)\n\nRun a GraphQL query anywhere, without a GraphQL server or a schema. Just pass in one resolver. Use it together with [graphql-tag](https://github.com/apollographql/graphql-tag).\n\n```\nnpm install graphql-anywhere graphql-tag\n```\n\nI think there are a lot of potentially exciting use cases for a completely standalone and schema-less GraphQL execution engine. We use it in [Apollo Client](https://github.com/apollostack/apollo-client) to read data from a Redux store with GraphQL.\n\nLet's come up with some more ideas - below are some use cases to get you started!\n\n## API\n\n```js\nimport graphql from 'graphql-anywhere'\n\ngraphql(resolver, document, rootValue?, context?, variables?, options?)\n```\n\n- `resolver`: A single resolver, called for every field on the query.\n    - Signature is: `(fieldName, rootValue, args, context, info) => any`\n- `document`: A GraphQL document, as generated by the template literal from `graphql-tag`\n- `rootValue`: The root value passed to the resolver when executing the root fields\n- `context`: A context object passed to the resolver for every field\n- `variables`: A dictionary of variables for the query\n- `options`: Options for execution\n\n#### Options\n\nThe last argument to the `graphql` function is a set of `graphql-anywhere`-specific options.\n\n- `resultMapper`: Transform field results after execution.\n    - Signature is: `(resultFields, resultRoot) => any`\n- `fragmentMatcher`: Decide whether to execute a fragment. Default is to always execute all fragments.\n    - Signature is: `(rootValue, typeCondition, context) => boolean`\n\n#### Resolver info\n\n`info`, the 5th argument to the resolver, is an object with supplementary information about execution. Send a PR or open an issue if you need additional information here.\n\n- `isLeaf`: A boolean that is `true` if this resolver is for a leaf field of the query, i.e. one that doesn't have a sub-selection.\n- `resultKey`: The key the result of this field will be put under. It's either the field name from the query, or the field alias.\n- `directives`: An object with information about all directives on this field. It's an object of the format `{ [directiveName]: { [argumentName]: value }}`. So for example a field with `@myDirective(hello: \"world\")` will be passed as `{ myDirective: { hello: 'world' }}`. Note that fields can't have multiple directives with the same name, as written in the GraphQL spec.\n\n\n## Utilities\n\nSee https://www.apollographql.com/docs/react/advanced/fragments.html for examples of how you might use these.\n\n```js\nimport { filter } from 'graphql-anywhere'\n\nfilter(doc, data);\n```\n\n- `doc`: a GraphQL document, as generated by the template literal from `graphql-tag`, typically either a query or a fragment.\n- `data`: an object of data to be filtered by the `doc`\n\nFilter `data` according to `doc`.\n\n\n```js\nimport { check } from 'graphql-anywhere'\n\ncheck(doc, data);\n```\n\n- `doc`: a GraphQL document, as generated by the template literal from `graphql-tag`, typically either a query or a fragment.\n- `data`: an object of data, as may have been filtered by `doc`.\n\nCheck that `data` is of the form defined by the query or fragment. Throw an exception if not.\n\n```js\nimport { propType } from 'graphql-anywhere'\n\nX.propTypes = {\n  foo: propType(doc),\n  bar: propType(doc).isRequired,\n}\n\n```\n\n- `doc`: a GraphQL document, as generated by the template literal from `graphql-tag`, typically either a query or a fragment.\n\nGenerate a React `propType` checking function to ensure that the passed prop is in the right form.\n\n### Supported GraphQL features\n\nWhy do you even need a library for this? Well, running a GraphQL query isn't as simple as just traversing the AST, since there are some pretty neat features that make the language a bit more complex to execute.\n\n- [x] Arguments\n- [x] Variables\n- [x] Aliases\n- [x] Fragments, both named and inline\n- [x] `@skip` and `@include` directives\n\nIf you come across a GraphQL feature not supported here, please file an issue.\n\n<a id=\"filter\"></a>\n## Example: Filter a nested object\n\n```js\nimport gql from 'graphql-tag';\nimport graphql from 'graphql-anywhere';\n\n// I don't need all this stuff!\nconst gitHubAPIResponse = {\n  \"url\": \"https://api.github.com/repos/octocat/Hello-World/issues/1347\",\n  \"title\": \"Found a bug\",\n  \"body\": \"I'm having a problem with this.\",\n  \"user\": {\n    \"login\": \"octocat\",\n    \"avatar_url\": \"https://github.com/images/error/octocat_happy.gif\",\n    \"url\": \"https://api.github.com/users/octocat\",\n  },\n  \"labels\": [\n    {\n      \"url\": \"https://api.github.com/repos/octocat/Hello-World/labels/bug\",\n      \"name\": \"bug\",\n      \"color\": \"f29513\"\n    }\n  ],\n};\n\n// Write a query that gets just the fields we want\nconst query = gql`\n  {\n    title\n    user {\n      login\n    }\n    labels {\n      name\n    }\n  }\n`;\n\n// Define a resolver that just returns a property\nconst resolver = (fieldName, root) => root[fieldName];\n\n// Filter the data!\nconst result = graphql(\n  resolver,\n  query,\n  gitHubAPIResponse\n);\n\nassert.deepEqual(result, {\n  \"title\": \"Found a bug\",\n  \"user\": {\n    \"login\": \"octocat\",\n  },\n  \"labels\": [\n    {\n      \"name\": \"bug\",\n    }\n  ],\n});\n```\n\n<a id=\"mock\"></a>\n## Example: Generate mock data\n\n```js\n// Write a query where the fields are types, but we alias them\nconst query = gql`\n  {\n    author {\n      name: string\n      age: int\n      address {\n        state: string\n      }\n    }\n  }\n`;\n\n// Define a resolver that uses the field name to determine the type\n// Note that we get the actual name, not the alias, but the alias\n// is used to determine the location in the response\nconst resolver = (fieldName) => ({\n  string: 'This is a string',\n  int: 5,\n}[fieldName] || 'continue');\n\n// Generate the object!\nconst result = graphql(\n  resolver,\n  query\n);\n\nassert.deepEqual(result, {\n  author: {\n    name: 'This is a string',\n    age: 5,\n    address: {\n      state: 'This is a string',\n    },\n  },\n});\n```\n<a id=\"normalizr\"></a>\n## Example: Read from a Redux store generated with Normalizr\n\n```js\nconst data = {\n  result: [1, 2],\n  entities: {\n    articles: {\n      1: { id: 1, title: 'Some Article', author: 1 },\n      2: { id: 2, title: 'Other Article', author: 1 },\n    },\n    users: {\n      1: { id: 1, name: 'Dan' },\n    },\n  },\n};\n\nconst query = gql`\n  {\n    result {\n      title\n      author {\n        name\n      }\n    }\n  }\n`;\n\nconst schema = {\n  articles: {\n    author: 'users',\n  },\n};\n\n// This resolver is a bit more complex than others, since it has to\n// correctly handle the root object, values by ID, and scalar leafs.\nconst resolver = (fieldName, rootValue, args, context): any => {\n  if (!rootValue) {\n    return context.result.map((id) => assign({}, context.entities.articles[id], {\n      __typename: 'articles',\n    }));\n  }\n\n  const typename = rootValue.__typename;\n  // If this field is a reference according to the schema\n  if (typename && schema[typename] && schema[typename][fieldName]) {\n    // Get the target type, and get it from entities by ID\n    const targetType: string = schema[typename][fieldName];\n    return assign({}, context.entities[targetType][rootValue[fieldName]], {\n      __typename: targetType,\n    });\n  }\n\n  // This field is just a scalar\n  return rootValue[fieldName];\n};\n\nconst result = graphql(\n  resolver,\n  query,\n  null,\n  data // pass data as context since we have to access it all the time\n);\n\n// This is the non-normalized data, with only the fields we asked for in our query!\nassert.deepEqual(result, {\n  result: [\n    {\n      title: 'Some Article',\n      author: {\n        name: 'Dan',\n      },\n    },\n    {\n      title: 'Other Article',\n      author: {\n        name: 'Dan',\n      },\n    },\n  ],\n});\n```\n\n## Example: Generate React components\n\nYou can use the `resultMapper` option to convert your results into anything you like. In this case, we convert the result fields into children for a React component:\n\n```js\nconst resolver = (fieldName, root, args) => {\n  if (fieldName === 'text') {\n    return args.value;\n  }\n\n  return createElement(fieldName, args);\n};\n\nconst reactMapper = (childObj, root) => {\n  const reactChildren = Object.keys(childObj).map(key => childObj[key]);\n\n  if (root) {\n    return cloneElement(root, root.props, ...reactChildren);\n  }\n\n  return reactChildren[0];\n};\n\nfunction gqlToReact(query): any {\n  return graphql(\n    resolver,\n    query,\n    '',\n    null,\n    null,\n    { resultMapper: reactMapper },\n  );\n}\n\nconst query = gql`\n  {\n    div {\n      s1: span(id: \"my-id\") {\n        text(value: \"This is text\")\n      }\n      s2: span\n    }\n  }\n`;\n\nassert.equal(\n  renderToStaticMarkup(gqlToReact(query)),\n  '<div><span id=\"my-id\">This is text</span><span></span></div>'\n);\n```\n",
    "licenseText": "The MIT License (MIT)\n\nCopyright (c) 2015 - 2016 Oleksandr Stubailo\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n"
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/graphql-anywhere/-/graphql-anywhere-4.2.7.tgz#c06fb40b1d62b39470c80e3731478dbbef060067",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/graphql-anywhere/-/graphql-anywhere-4.2.7.tgz",
    "hash": "c06fb40b1d62b39470c80e3731478dbbef060067",
    "integrity": "sha512-fJHvVywWVWjiHuPIMs16Nfjf4zdQUwSO1LKycwBJCWIPeoeQ8LqXK2BgYoZAHkhKEFktZZeYyzS4o/uIUG0z5A==",
    "registry": "npm",
    "packageName": "graphql-anywhere",
    "cacheIntegrity": "sha512-fJHvVywWVWjiHuPIMs16Nfjf4zdQUwSO1LKycwBJCWIPeoeQ8LqXK2BgYoZAHkhKEFktZZeYyzS4o/uIUG0z5A== sha1-wG+0Cx1is5RwyA43MUeNu+8GAGc="
  },
  "registry": "npm",
  "hash": "c06fb40b1d62b39470c80e3731478dbbef060067"
}