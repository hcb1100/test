{
  "manifest": {
    "name": "apollo-link-persisted-queries",
    "version": "0.2.2",
    "description": "Use persisted queries with Apollo Link",
    "author": {
      "name": "James Baxley",
      "email": "james@meteor.com"
    },
    "license": "MIT",
    "main": "./lib/bundle.umd.js",
    "module": "./lib/index.js",
    "jsnext:main": "./lib/index.js",
    "typings": "./lib/index.d.ts",
    "repository": {
      "type": "git",
      "url": "git+https://github.com/apollographql/apollo-link-persisted-queries.git"
    },
    "bugs": {
      "url": "https://github.com/apollographql/apollo-link-persisted-queries/issues"
    },
    "homepage": "https://github.com/apollographql/apollo-link-persisted-queries#readme",
    "scripts": {
      "build:browser": "browserify ./lib/bundle.umd.js -o=./lib/bundle.js --i apollo-link --i graphql && npm run minify:browser",
      "build": "tsc -p .",
      "bundle": "rollup -c",
      "clean": "rimraf lib/* && rimraf coverage/*",
      "coverage:upload": "codecov",
      "danger": "danger run --verbose",
      "filesize": "npm run build && npm run build:browser && bundlesize",
      "lint": "prettier --trailing-comma all --single-quote --write \"src/**/*.{j,t}s*\"",
      "lint-staged": "lint-staged",
      "minify:browser": "uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.js",
      "postbuild": "npm run bundle",
      "prebuild": "npm run clean",
      "prepublishOnly": "npm run clean && npm run build",
      "test": "jest",
      "coverage": "npm run lint && jest --coverage",
      "watch": "tsc -w -p ."
    },
    "dependencies": {
      "apollo-link": "^1.2.1",
      "hash.js": "^1.1.3"
    },
    "peerDependencies": {
      "graphql": "^0.11.0 || ^0.12.0 || ^0.13.0 || ^14.0.0"
    },
    "devDependencies": {
      "@types/graphql": "0.11.5",
      "@types/jest": "21.1.5",
      "@types/node": "^8.0.53",
      "apollo-cache-inmemory": "^1.1.4",
      "apollo-client": "^2.0.4",
      "apollo-link-http": "^1.5.0",
      "browserify": "14.5.0",
      "bundlesize": "0.15.3",
      "codecov": "^3.1.0",
      "danger": "^6.0.2",
      "graphql": "^14.0.2",
      "graphql-tag": "^2.5.0",
      "jest": "^23.6.0",
      "jest-fetch-mock": "^1.3.3",
      "js-sha256": "^0.7.1",
      "lerna": "2.4.0",
      "lint-staged": "4.3.0",
      "lodash": "^4.17.4",
      "pre-commit": "1.2.2",
      "prettier": "1.7.4",
      "react": "^16.2.0",
      "react-apollo": "^2.0.4",
      "react-dom": "^16.2.0",
      "rimraf": "2.6.1",
      "rollup": "0.45.2",
      "ts-jest": "21.1.4",
      "typescript": "2.5.1",
      "uglify-js": "3.1.5"
    },
    "jest": {
      "transform": {
        ".(ts|tsx)": "<rootDir>/node_modules/ts-jest/preprocessor.js"
      },
      "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
      "moduleFileExtensions": [
        "ts",
        "tsx",
        "js",
        "json"
      ],
      "setupFiles": [
        "./scripts/jest.js"
      ]
    },
    "bundlesize": [
      {
        "name": "apollo-link-persisted-queries",
        "path": "./lib/bundle.min.js",
        "maxSize": "3.9 kb"
      }
    ],
    "lint-staged": {
      "*.ts*": [
        "prettier --trailing-comma all --single-quote --write",
        "git add"
      ],
      "*.js*": [
        "prettier --trailing-comma all --single-quote --write",
        "git add"
      ],
      "*.json*": [
        "prettier --write",
        "git add"
      ]
    },
    "pre-commit": "lint-staged",
    "_registry": "npm",
    "_loc": "/home/tel/.cache/yarn/v6/npm-apollo-link-persisted-queries-0.2.2-156597cb259b7bb56cf4e967a7be0312954f4591-integrity/node_modules/apollo-link-persisted-queries/package.json",
    "readmeFilename": "README.md",
    "readme": "Automatic Persisted Queries\n---\n\n## Problem to solve\nUnlike REST APIs that use a fixed URL to load data, GraphQL provides a rich query language that can be used to express the shape of application data requirements.  This is a marvellous advancement in technology, but it comes at a cost: GraphQL query strings are often much longer than REST URLS â€” in some cases by many kilobytes.\n\nIn practice we've seen GraphQL query sizes ranging well above 10 KB *just for the query text*.  This is actually significant overhead when compared with a simple URL of 50-100 characters.  When paired with the fact that the uplink speed from the client is typically the most bandwidth-constrained part of the chain, large queries can become bottlenecks for client performance.\n\nAutomatic Persisted Queries solves this problem by sending a generated ID instead of the query text as the request.\n\nFor more information about this solution, read [this article announcing Automatic Persisted Queries](https://dev-blog.apollodata.com/improve-graphql-performance-with-automatic-persisted-queries-c31d27b8e6ea).\n\n## How it works\n1. When the client makes a query, it will optimistically send a short (64-byte) cryptographic hash instead of the full query text.\n2. If the backend recognizes the hash, it will retrieve the full text of the query and execute it.\n3. If the backend doesn't recogize the hash, it will ask the client to send the hash and the query text to it can store them mapped together for future lookups. During this request, the backend will also fulfill the data request.\n\nThis library is a client implementation for use with Apollo Client by using custom Apollo Link.\n\n## Installation\n\n`npm install apollo-link-persisted-queries --save`\n\n## Usage\n\nThe persisted query link requires using the `http-link`. The easiest way to use them together to to concat them into a single link.\n\n```js\nimport { createPersistedQueryLink } from \"apollo-link-persisted-queries\";\nimport { createHttpLink } from \"apollo-link-http\";\nimport { InMemoryCache } from \"apollo-cache-inmemory\";\nimport ApolloClient from \"apollo-client\";\n\n\n// use this with Apollo Client\nconst link = createPersistedQueryLink().concat(createHttpLink({ uri: \"/graphql\" }));\nconst client = new ApolloClient({\n  cache: new InMemoryCache(),\n  link: link,\n});\n```\n\nThats it! Now your client will start sending query signatures instead of the full text resulting in improved network performance!\n\n#### Options\nThe createPersistedQueryLink function takes an optional object with configuration. Currently the only supported configutations are a key called `generateHash` which receives the query and returns the hash, a function to conditionally disabled sending persisted queries on error\n- `generateHash`: a function that takes the query document and returns the hash. If not provided, `generateHash` defaults to a fast implementation of sha256 + hex digest.\n- `useGETForHashedQueries`: set to `true` to use the HTTP `GET` method when sending the hashed version of queries (but not for mutations). `GET` requests require `apollo-link-http` 1.4.0 or newer, and are not compatible with `apollo-link-batch-http`. \n> If you want to use `GET` for non-mutation queries whether or not they are hashed, pass `useGETForQueries: true` option to `createHttpLink` from `apollo-link-http` instead. If you want to use `GET` for all requests, pass `fetchOptions: {method: 'GET'}` to `createHttpLink`.\n- `disable`: a function which takes an ErrorResponse (see below) and returns a boolean to disable any future persited queries for that session. This defaults to disabling on `PersistedQueryNotSupported` or a 400 or 500 http error\n\n**ErrorResponse**\nThe argument that the optional `disable` function is given is an object with the following keys:\n- `operation`: The Operation that errored (contains query, variables, operationName, and context)\n- `response`: The Execution of the reponse (contains data and errors as well extensions if sent from the server)\n- `graphQLErrors`: An array of errors from the GraphQL endpoint\n- `networkError`: any error during the link execution or server response\n\n*Note*: `networkError` is the value from the downlink's `error` callback. In most cases, `graphQLErrors` is the `errors` field of the result from the last `next` call. A `networkError` can contain additional fields, such as a GraphQL object in the case of a failing HTTP status code from `apollo-link-http`. In this situation, `graphQLErrors` is an alias for `networkError.result.errors` if the property exists.\n\n## Apollo Engine\nApollo Engine supports receiving and fulfulling Automatic Persisted Queries. Simply adding this link into your client app will improve your network response times when using Apollo Engine.\n\n\n### Protocol\nAutomatic Persisted Queries are made up of three parts: the query signature, error responses, and the negotiaion protocol.\n\n**Query Signature**\nThe query signature for Automatic Persisted Queries is sent along the extensions field of a request from the client. This is a transport independent way to send extra information along with the operation. \n\n```js\n{\n  operationName: 'MyQuery',\n  variables: null,\n  extensions: {\n    persistedQuery: {\n      version: 1,\n      sha256Hash: hashOfQuery\n    }\n  }\n}\n```\n\nWhen sending an Automatic Persisted Query, the client ommits the `query` field normally present, and instead sends an extension field with a `persistedQuery` object as shown above. The hash algorithm defaults to a `sha256` hash of the query string.\n\nIf the client needs to register the hash, the query signature will be the same but include the full query text like so:\n\n```js\n{\n  operationName: 'MyQuery',\n  variables: null,\n  query: `query MyQuery { id }`,\n  extensions: {\n    persistedQuery: {\n      version: 1,\n      sha256Hash: hashOfQuery\n    }\n  }\n}\n```\n\nThis should only happen once across all clients when a new query is introduced into your application.\n\n**Error Responses**\nWhen the initial query signature is received by a backend, if it is unable to find the hash previously stored, it must send back the following response signature:\n\n```js\n{\n  errors: [\n    { message: 'PersistedQueryNotFound' }\n  ]\n}\n```\n\nIf the backend doesn't support Automatic Persisted Queries, or does not want to support it for that particular client, it can send back the following which will tell the client to stop trying to send hashes all together:\n\n```\n{\n  errors: [\n    { message: 'PersistedQueryNotSupported' }\n  ]\n}\n```\n\n**Negotiation Protocol**\nIn order to support Automatic Persisted Queries, the client and server must follow the negotiaion steps as outlined here:\n\n*Happy Path*\n1. Client sends query signature with no `query` field\n2. Server looks up query based on hash, if found, it resolves the data\n3. Client receives data and completes request\n\n*Missing hash path*\n1. Client sends query signature with no `query` field\n2. Server looks up query based on hash, none is found\n3. Server responds with NotFound error response\n4. Client sends both hash and query string to Server\n5. Server fulfills response and saves query string + hash for future lookup\n6. Client receives data and completes request\n\n### Build time generation\nIf you want to avoid hashing in the browser, you can use a build script to include the hash as part of the request. Then you pass a function to retrieve that hash when the operation is run. This works well with projects like [this](https://github.com/leoasis/graphql-persisted-document-loader) which uses webpack to generate the hashes at build time.\n\nIf you use the above loader, you can pass `{ generateHash: ({ documentId }) => documentId }` to the `createPersistedQueryLink` call.\n",
    "licenseText": "The MIT License (MIT)\n\nCopyright (c) 2016 - 2017 Meteor Development Group, Inc.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/apollo-link-persisted-queries/-/apollo-link-persisted-queries-0.2.2.tgz#156597cb259b7bb56cf4e967a7be0312954f4591",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/apollo-link-persisted-queries/-/apollo-link-persisted-queries-0.2.2.tgz",
    "hash": "156597cb259b7bb56cf4e967a7be0312954f4591",
    "integrity": "sha512-YL7XBu/5QsSbbYaWUXgm87T2Hn/2AQZk5Wr8CLXGDr3Wl3E/TRhBhKgQQTly9xhaTi7jgBO+AeIyTH5wCBHA9w==",
    "registry": "npm",
    "packageName": "apollo-link-persisted-queries",
    "cacheIntegrity": "sha512-YL7XBu/5QsSbbYaWUXgm87T2Hn/2AQZk5Wr8CLXGDr3Wl3E/TRhBhKgQQTly9xhaTi7jgBO+AeIyTH5wCBHA9w== sha1-FWWXyyWbe7Vs9Olnp74DEpVPRZE="
  },
  "registry": "npm",
  "hash": "156597cb259b7bb56cf4e967a7be0312954f4591"
}